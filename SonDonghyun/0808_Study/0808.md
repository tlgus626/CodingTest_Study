0808 Study
============
### 1. 비밀지도
- 구현
 - bin 함수를 써서 이진법 출력하고, result라는 리스트에 빈 문자열 원소 생성
 - 반복문으로 확인해서 공백 혹은 # 을 채워넣음
### 2. 실패율
- 구현
 - Counter함수로 스테이지 도달 수 딕셔너리로 받음
 - 실패율을 조건문을 사용해 계산
### 3. 체육복
- 집합
 - 집합 자료형으로 잘 생각해서 교집합과 차집합을 잘 고려해서 풀었음
### 4. 최댓값과 최솟값
- 문자열
 - 쉽게 해결했음
### 5. 피보나치 수
- 스택/큐
 - 큐를 사용해 앞, 뒤 숫자를 저장하지 않고 풀려고 했음
### 6. N개의 최소공배수
- 수학
 - 소수를 직접 리스트에 지정
 - 소인수와 지수를 활용하여 해결
***
Feedback
-----------
### a) 비밀지도
- zip() 함수를 사용해 두 arr1, arr2를 한번에 돌리면 시간복잡도 줄일 수 있음
- 이진법 출력하고 나서 0을 채워넣을 때, .zfill(n) 함수를 쓰면 좌측에 n에서 부족한 글자수만큼 0을 채워넣을 수 있음
### b) 실패율
- for문 안 쓴 다운이의 풀이 참고
- for문 안에 map 함수를 쓰면 시간복잡도 매우 커짐 
### c) 체육복
- return에서 쓸데없는 세트 컴프리헨션 빼고 n - len(lost) 할 것
### d) 최댓값과 최솟값
- min, max 함수를 쓰지 않고 직접 정의해보는 것도 좋을 듯
### e) 피보나치 수
- 다른 친구들은 리스트의 마지막 인덱스 두 개를 더하는 식으로 함
- 그렇게만 해도 시간 복잡도나 공간 복잡도 크지 않음
- 그리고 함수 굳이 F 정의 안 해도 됨
### f) N개의 최소공배수
- 일일히 구하는 코드라 상당히 투박함
- 리스트 내 가장 큰 수의 배수를 구해서 리스트의 모든 원소로 나눴을 때 나머지가 0이면 최소공배수(훨씬 합리적!)
- 소수 계산할 때, 에라토스테네스의 체를 쓰는게 더 경제적
- 아니면, n의 제곱근보다 작은 소수로 n을 나눴을 때 나머지가 0이 나오지 않으면 그 수는 소수라는 판별법도 있음

