0921 Study
===========
### 1. 2^n 배열 자르기
- 수리력
 - left와 right를 n으로 나눈 몫과 나머지를 계산
 - 그 사이 arr를 생성하여 시간복잡도 줄임
 - 첫번째 몫과 두번째 몫이 같은 경우와 다른 경우를 따로 나누어 처리
### 2. 모음사전
- 구현
 - 단어로 가능한 모든 조합 리스트 만들고 sorted
 - 단어 리스트에서 찾는 단어 인덱스 위치 + 1 
### 3. 2개 이하로 다른 비트
- 수리력
 - 이진법으로 변환한 마지막 자리수가 0이면 -> 마지막 자리만 1로 바꿔줌
 - 마지막 자리수가 1이면, rfind('0')로 가장 오른쪽에 있는 '0' 위치 찾고 그 자리를 '1'로 바꾸고 그 뒷자리를 '0'으로 변환
### 4. 주식가격
- 스택/큐
 - 시간효율성 못 줄여서 답 봄
 - 나도 똑같이 이중반복 썼지만, 인덱스로만 접근 안 하고 enumerate를 사용한 차이가 컸던 거 같음
***
Feedback
------------
### a) 2^n 배열 자르기
- 몫과 나머지를 이용하지 않으면 효율성이 크게 떨어지는 문제
### b) 모음사전
- 나는 모든 경우의 수를 만들었는데 그보다는 인덱스 위치를 계산할 수 있다는 점
- 각 aeiou에 0부터 4까지 번호를 매기고, 그 word 단어를 for문을 써서 각 단어의 인덱스에 5**(5-i) // 4 * (aeiou 번호 +1)
### c) 2개 이하로 다른 비트
- 지우의 풀이: >>와 ^라는 bit연산자를 써서 문제 내 규칙을 활용
- 감탄스러웠음..
### d) 주식가격
- 인덱스로만 접근하면 시간복잡도를 줄일 수 있음
- 큐나 스택으로 풀어도 좋을듯
